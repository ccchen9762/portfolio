{
    "projects": [
        {
            "title": "Ray Marching Ocean", 
            "time": "2025 Summer",
            "tags": ["3D rendering"],
            "link": "https://www.shadertoy.com/view/tX33RX",
            "cover": {
                "src": "ocean1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "ocean1.jpg", 
                    "alt": "img1",
                    "type": "img"
                }
            ],
            "description": "The dynamic background of this portfolio is a real-time WebGL rendering, a personal project inspired by a captivating Shadertoy shader. The scene is a procedural generated ocean, brought to life using the ray marching algorithm. \n\n The ocean's realistic surface is crafted with Fractal Brownian Motion (FBM), a technique that simulates natural, undulating textures. I've also incorporated a starry night sky, generated with cellular noise, and a moon texture created through layered noise. Enjoy the view and check out the link to see how it works!"
        },
        {
            "title": "Optimizing Twitch for Portrait Monitors: A Tampermonkey Solution", 
            "time": "2025 Summer",
            "tags": ["Journal", "Web development"],
            "link": "https://github.com/ccchen9762/tampermonkey_scripts",
            "cover": {
                "src": "twitch_chat1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "twitch_chat1.jpg", 
                    "alt": "img1",
                    "type": "img"
                }
            ],
            "description": "I use a dual-monitor PC setup, one in landscape mode and one in portrait mode. In my casual time, I often enjoy watching Twitch streams on my portrait monitor while simultaneously working on other tasks on my landscape screen. However, Twitch's default layout isn't well-optimized for portrait orientation. The chat panel occupies the entire height of the right side, leaving the video stream with only half the screen's width, which makes it difficult to watch. Furthermore, the channel information displayed below the stream often holds little relevance while actively watching. To address the issues, I decided to develop a Tampermonkey script to reposition the chat panel beneath the video stream. \n\n My first idea was to programmatically swap the positions of the chat div and the channel information div within the page's DOM structure. After this rearrangement, I planned to use Twitch's built-in 'collapse chat' button functionality to hide the (now relocated) channel information, achieving the desired layout. Through some DOM searching and using appendChild, I was able to easily perform this swap. Visually, this approach worked. \n\n However, I soon discovered that the buttons within the chat panel had stopped functioning. Since I couldn't determine how Twitch's internal JavaScript triggers onclick events, it was challenging to restore their functionality after altering the DOM structure. This led me to consider a different strategy. \n\n I decided on an alternative approach focused on rearranging page elements using CSS properties rather than structural DOM changes. I applied display: grid to the common ancestor div of the video player and chat, then modified the order of its descendant elements. \n\n The goal was still to make the stream div extend to the far right of the page, which typically requires 'collapsing' the chat. However, I needed the chat element to remain visible in its new position. I inspected the classList of the chat and related elements in both their collapsed and expanded states. By applying the appropriate classes, I could mimic the visual behavior of a collapsed chat while keeping it visible and correctly positioned. \n\n After a process of trial and error, I successfully identified the correct CSS settings and script actions. Now, the chat panel on my portrait monitor is correctly positioned beneath the stream, and critically, all its buttons are fully functional."
        },
        {
            "title": "Raspberry Pi 5 USB Wi-Fi Adapter Installation: A Troubleshooting Journey", 
            "time": "2025 Spring",
            "tags": ["Raspberry Pi", "Linux"],
            "link": "",
            "cover": {
                "src": "rpi1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "rpi1.jpg", 
                    "alt": "img1",
                    "type": "img"
                }
            ],
            "description": "Recently, I decided to host a Wi-Fi hotspot on my Raspberry Pi 5. Unfortunately, the Raspberry Pi 5 only has one built-in Wi-Fi adapter. This means that using it to host a hotspot would prevent it from connecting to an existing Wi-Fi network simultaneously. To overcome this limitation, I purchased a USB Wi-Fi adapter. \n\n After some research, I settled on the ASUS AX1800 USB AX56 Nano. While it doesn't have an official Linux driver, online resources suggested its chipset was Linux-compatible. I consulted Gemini, which indicated the adapter's chipset was rtl8852au, also pointing me to a GitHub repository with a Debian-based Linux driver: 'https://github.com/lwfinger/rtl8852au'. The installation instructions were straightforward, but even after following them, the ip a command didn't show any new Wi-Fi adapters. Rebooting and reinstalling didn't resolve the issue, leading me to suspect the chipset might not be rtl8852au after all. I tried to find the specifications for the AX56 Nano, but interestingly, all other similar ASUS models had detailed spec pages except this one. \n\n I then attempted to identify the chipset using the USB ID from the 'lsusb' command. This ID was associated with both the AX55 Nano and the regular AX56, with chipsets of rtl8852bu and rtl8852au respectively, making identification difficult. To confirm, I connected the adapter to my Windows PC, where it had official driver support. After installing the Windows driver, I finally confirmed via Device Manager that the chipset of the ASUS AX1800 USB AX56 Nano was indeed rtl8852bu instead of rtl8852au. \n\n Thankfully, a driver for the rtl8852bu chipset was also available on GitHub: https://github.com/lwfinger/rtl8852bu. After installing this driver, the USB Wi-Fi adapter finally worked! I also noted that the driver needed to be reloaded after each reboot, so I created /etc/modprobe.d/8852bu.conf to ensure it loaded automatically. \n\n With the adapter working, I proceeded to host a hotspot and connected my phone to test it. However, I noticed the original Wi-Fi connection on the Raspberry Pi stopped working. Upon investigation, I realized this was likely due to an IP address conflict, as both my hotspot and the Wi-Fi router were using the same local IP range and subnet mask. I modified the hotspot's configuration to use a different IP address range, and both connections worked. \n\n My next step was to restrict SSH access to only my trusted devices. For my PC, I generated SSH keys using 'ssh-keygen -t rsa -b 4096' on the client machine and copied the contents of id_rsa.pub to ~/.ssh/authorized_keys on the Raspberry Pi. I then disabled password authentication by editing /etc/ssh/sshd_config and setting PasswordAuthentication no, followed by restarting the SSH service with sudo systemctl restart sshd. For my Android device, I used JuiceSSH to generate keys and performed a similar operation to authorize it on the Raspberry Pi. \n\n To further secure the Raspberry Pi, I restricted incoming connections. Since Raspberry Pi OS doesn't have a default firewall, I installed ufw. I then created rules to allow SSH traffic 'sudo ufw allow ssh' and incoming connections on the hotspot interface 'sudo ufw allow in on <adapter id>', while blocking all other incoming connections with 'sudo ufw default deny incoming'. \n\n At one point, I accidentally deleted my hotspot settings and had to recreate them. This time, I selected WPA3 encryption. To my surprise, the hotspot began restarting repeatedly. I spent some time troubleshooting, initially suspecting a driver issue. However, turns out actually AX56 Nano does not support WPA3. It would not log any error messages when configured with WPA3, it would simply restart itself. Changing the security setting back to WPA2 resolved the issue."
        },
        {
            "title": "Unity-2D-strategy-game", 
            "time": "2023 Spring",
            "tags": "Game development",
            "link": "https://fingerblack.github.io/LostSheeps/",
            "cover": {
                "src": "lostsheeps.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/_9Z4_0w9e4Y", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "LostSheeps is a Unity 2D strategy game developed by a 6-member team. With ideas from push the box game, you will fight the enemies in an innovative way. In this game I am in charge of abstract class design, enemy and turret scripts and story UI. Defining abstract class of enemy and turret and inherit from them make development a lot easier like add a new kind of enemy or access all turrets in script. Definitely checkout the link and play it yourself!"
        },
        {
            "title": "Impulse-based-physics-system", 
            "time": "2022 Fall",
            "tags": ["3D rendering", "Animation"],
            "link": "",
            "cover": {
                "src": "physics1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/TFW36F5cc_0", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "This impulse based physics system is an extension of game engine base from class (Prime Engine). I implemented sphere and OBB collider, and update object position with velocity and angular velocity calculated by momentum reservation that applied to collider. For OBB to OBB collision, I use seperating axis theorem to check collision. Each cycle update position based on frame time times speed. In video cyan boxes are meshes debuggers, orange boxes are colliders."
        },
        {
            "title": "Inverse-Kinematics", 
            "time": "2022 Spring",
            "tags": ["3D rendering", "Animation"],
            "link": "",
            "cover": {
                "src": "IK1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/FYHRDi22t98", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "Inverse Kinematics is a process to place node tree with desire end points position. In this project I implemented damped least square method and pseudo inverse algorithm, and use linear blending and dual quaternion for skinning. Video above has 3 parts, first part demonstrates linear blending with damped least square method, second part is linear blending with pseudo inverse, and third part is damped least square method and switches between linear blending and dual quaternion skinning algorithms."
        },
        {
            "title": "Angular-stock-search-website", 
            "time": "2022 Spring",
            "tags": ["Web development"],
            "link": "https://myfirstnodejs-343823.wm.r.appspot.com/",
            "cover": {
                "src": "stock_search1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "stock_search1.jpg", 
                    "alt": "img1",
                    "type": "img"
                }
            ],
            "description": "This stock search website using Angular framework as front-end and express framework Node.js back-end. The search bar is implemented with auto-complete, back-end will query finnhub.io with user input for a list of possible stock symbol. After choose stock, back-end will gathering information from finnhub and shows summary such as recent price, news and charts. User can simulate buying stocks with mock trading functionality. With HTML5 local storage, it can save previous simulated stock trade of user locally."
        },
        {
            "title": "Motion-capture-interpolation", 
            "time": "2022 Spring",
            "tags": ["3D rendering", "Animation"],
            "link": "",
            "cover": {
                "src": "mocap_interpolation1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/vHeksIJ06DM", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "With a list of keyframe data points, interpolate from them can generate a complete and smooth motion. This project use linear Euler angle, Bezier Euler angle, quaternion SLERP, and Bezier quaternion SLERP to restore a motion capture with keyframe points. Video demonstrates the original motion capture and regenerated motion from the 4 methods mentioned earlier. Generally, euler models have exaggerate rotation when angle is large while quaternion models are more close to original. Linear models have stiffer motion while Bezier have smooth rotation."
        },
        {
            "title": "Physically-based-simulation", 
            "time": "2022 Spring",
            "tags": ["3D rendering", "Animation"],
            "link": "",
            "cover": {
                "src": "jello_cube1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/s-GF7p1fJ0g", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "This project uses a spring-mass system for simulating jello cube bouncing inside an area. With structure bend, and shear springs, it react with force and update position with Runge-Kutta Method of Order 4 (RK4) and Euler integrators. When collide with walls, penalty based force is applied to jelly. Also jelly cube is affect by force field and mouse input."
        },
        {
            "title": "Ray-Tracer", 
            "time": "2021 Fall",
            "tags": ["3D rendering"],
            "link": "",
            "cover": {
                "src": "ray_tracer1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "ray_tracer1.jpg", 
                    "alt": "img1",
                    "type": "img"
                },
                {
                    "src": "ray_tracer2.jpg", 
                    "alt": "img2",
                    "type": "img"
                },
                {
                    "src": "ray_tracer3.jpg", 
                    "alt": "img3",
                    "type": "img"
                }
            ],
            "description": "Backward Ray-tracer is a way of rendering that simulates actual light. First calculating light intersections with objects inside the scene, then reflect the light to find next intersection. Repeat this operation to accumulate the pixel color. I implemented with multiple reflections and soft shadows. Also, every pixel is rendered by averaging 4 rays for anti-aliasing."
        },
        {
            "title": "Catmull-Rom-Splines", 
            "time": "2021 Fall",
            "tags": ["3D rendering"],
            "link": "",
            "cover": {
                "src": "roller_coaster1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/1xIiHSqa4d4", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "Catmull-Rom-Splines can generate smooth curve that has continuous tangent vectors from a list of data points. The video above uses 26 3D points to generate roller coaster rails, and render with recursive subdivision. The cart then moves along the tangent vector of rail. For enironment I use sky box texture, random position and size of trees and floor with grass texture."
        },
        {
            "title": "JPEG-Compression", 
            "time": "2017 Fall",
            "tags": ["Image Processing"],
            "link": "",
            "cover": {
                "src": "jpeg1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "jpeg1.jpg", 
                    "alt": "img1",
                    "type": "img"
                },
                {
                    "src": "jpeg2.jpg", 
                    "alt": "img2",
                    "type": "img"
                }
            ],
            "description": "A Jpeg compression implementation of encoder and decoder on grayscale raw files. The process goes through subsampling, DCT, Quatization, then first number of each block do DC differetial coding, the rest of numbers do AC run-length coding with zigzag order. The images above is encoded and decoded with quality factor of 50 and have PSNR value of 26.1336 and 33.6993"
        },
        {
            "title": "Java-Mario-Like-Game", 
            "time": "2016 Spring",
            "tags": ["Game Development"],
            "link": "",
            "cover": {
                "src": "dashan1.jpg", 
                "alt": "img1",
                "type": "img"
            },
            "images": [
                {
                    "src": "https://www.youtube.com/embed/sU1U4YHqqjw", 
                    "alt": "vid1",
                    "type": "video"
                }
            ],
            "description": "A 2D Mario-like game made with Lightweight Java Game Library. Implemented level and game loop from scratch, including character animation, 2D AABB collision and scene change."
        }
    ]
}